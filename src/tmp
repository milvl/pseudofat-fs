// create a dummy filesystem for now
	pTmpFs := pseudo_fat.GetUninitializedFileSystem()
	pTmpFs.DiskSize = 4008032
	pTmpFs.ClusterSize = 4000
	pTmpFs.FatCount = 1000
	pTmpFs.Fat01StartAddr = 32
	pTmpFs.Fat02StartAddr = 4032
	pTmpFs.DataStartAddr = 8032
	copy(pTmpFs.Signature[:], consts.AuthorID)
	logging.Debug(fmt.Sprintf("Dummy filesystem: %s", pTmpFs.ToString()))
	// convert the filesystem to bytes
	fsBytes, err := utils.StructToBytes(pTmpFs)
	if err != nil {
		logging.Error(fmt.Sprintf("Error converting filesystem to bytes: %s", err))
		os.Exit(consts.ExitFailure)
	}
	// write the filesystem to the file
	// expand the fsBytes to the size of the filesystem
	fsBytes = append(fsBytes, make([]byte, pTmpFs.DiskSize-uint32(len(fsBytes)))...)
	_, err = file.Write(fsBytes)
	if err != nil {
		logging.Error(fmt.Sprintf("Error writing filesystem to the file: %s", err))
		os.Exit(consts.ExitFailure)
	}


// Mkdir creates a new directory in the specified parent directory.
//
// It returns ErrNoFreeCluster if there are no free clusters in the FAT.
// It returns ErrNilPointer if any of the pointers are nil.
func Mkdir(pFs *pseudo_fat.FileSystem, pDir *pseudo_fat.DirectoryEntry, fats [][]int32, data []byte, dirName string) error {
	// sanity checks
	if pFs == nil || pDir == nil || fats == nil || data == nil {
		return custom_errors.ErrNilPointer
	}

	fat := fats[0]

	// get the cluster chain for the parent directory
	clusterChain, err := getClusterChain(pDir.StartCluster, fat)
	if err != nil {
		return fmt.Errorf("failed to get cluster chain: %w", err)
	}
	clusterEndIndex := clusterChain[len(clusterChain)-1]

	// find a free cluster for the parent directory new entry
	freeClusterIndexParent, err := findFreeCluster(fat)
	if err != nil {
		return err
	}

	// update the FAT
	addToFat(fats, clusterEndIndex, freeClusterIndexParent)

	// find a free cluster for the new directory
	freeClusterIndex, err := findFreeCluster(fat)
	if err != nil {
		return err
	}

	// write the new directory entry
	pNewDirEntry := NewDirectoryEntry(false, 0, freeClusterIndex, pDir.StartCluster, dirName)
	markEndOfChain(fats, freeClusterIndex)

	// serialize the directory entry
	newDirEntryBytes, err := StructToBytes(pNewDirEntry)
	if err != nil {
		return fmt.Errorf("failed to serialize directory entry: %w", err)
	}

	// write the new directory entry to the data region
	byteOffset := int(freeClusterIndexParent) * int(pFs.ClusterSize)
	copy(data[byteOffset:], newDirEntryBytes)

	return nil
}

// GetDirEntryFromRoot retrieves the directory entry from the root directory.
func GetDirEntryFromRoot(pFs *pseudo_fat.FileSystem, fats []([]int32), data []byte, absPath string) (*pseudo_fat.DirectoryEntry, error) {
	// sanity checks
	if pFs == nil || fats == nil || data == nil || absPath == "" {
		return nil, custom_errors.ErrNilPointer
	}

	// get the root directory entry
	pRootDirEntry, err := GetRootDirEntry(pFs, fats, data)
	if err != nil {
		return nil, fmt.Errorf("failed to get root directory entry: %w", err)
	}

	// find the directory entry
	dirs, err := GetNormalizedPathNodes(absPath)
	if err != nil {
		return nil, fmt.Errorf("failed to get normalized path: %w", err)
	}
	pCurrDir := pRootDirEntry
	found := false

	for _, dirName := range dirs {
		entries, err := GetDirEntries(pFs, pCurrDir, fats, data)
		if err != nil {
			return nil, fmt.Errorf("failed to get directory entries: %w", err)
		}

		found = false
		for _, entry := range entries {
			if NormalizeStringFromMem(entry.Name[:]) == dirName && !entry.IsFile {
				logging.Debug(fmt.Sprintf("Found directory: \"%s\" on path: \"%s\"", dirName, absPath))
				pCurrDir = entry
				found = true
				break
			}
		}

		if !found {
			return nil, custom_errors.ErrDirNotFound
		}
	}

	if !found {
		return nil, custom_errors.ErrDirNotFound
	} else {
		return pCurrDir, nil
	}
}